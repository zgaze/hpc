# 线程的概念
线程是操作系统中被调度执行的单位，是最小执行单元，操作系统把线程叫任务。

## 执行流
一个线程里被执行的代码行会被编译成汇编指令，所以，依次执行的代码，会转变为一个被依次执行的指令序列，这个指令序列就是执行流，一个执行流对应一个线程，多个执行流并发执行的情况就叫多线程程序。

注意：这个指令序列跟代码顺序不一样，代码中的条件分支和跳转返回语句等会影响执行流。

## 逻辑线程和硬件线程
线程的执行逻辑由代码描述，比如编写一个函数实现对一个整型数组的元素求和：
```c++
int Sum(int a[], int n) {
    int x = 0;
    for (int i = 0; i < n; ++i) 
        x += a[i];
    return x;
}
```
这个函数的逻辑很简单，它没有再调用其他函数，我们可以开一个线程去执行这个函数对某数组求和。

函数描述了逻辑，即要做什么、以及怎么做，它偏设计，它没有描述物质，即没有描述这个事情由谁做，事情最终需要派发到实体去完成。

程序上的线程是一个逻辑上的概念，也叫任务、软线程、逻辑线程；需要跟芯片的线程概念做区分，芯片上的线程的概念，通常指为执行指令序列而配套的硬件单元，所以也叫硬线程。

一个软件线程由哪个CPU核心去执行、以及何时执行，则不归应用程序员管，它由操作系统决定，操作系统中的调度系统负责这项工作。

# 线程、核心、函数的关系

## 线程入口函数
每个线程都会有一个入口函数，线程从入口函数开始执行，一行代码接着一行代码执行，中间它可能会调用其他函数，那么它的控制流就转到了被调用的函数继续执行，被调用函数里还可以继续调用其他函数，这样便形成一个函数调用链。

前面的数组求和例子，如果数组特别大，则求和耗时长，那么，可以把这个整型数组分成多个小数组，或者表示成二维数组（数组的数组），每个线程负责一个小数组的求和，多个线程并发执行，最后再累加结果。所以，为了提升处理速度，可以让多个线程执行相同或者相似的计算逻辑。同样的处理逻辑可以有多个执行实例，即多个线程。

当然，也可以为两个线程指定不同的入口函数，让各线程执行不同的计算逻辑。

打个比方，假设有遛狗、扫地、做饭3项工作要做。

- 遛狗就是为狗系上绳子然后牵着它在小区里溜达一圈，这句话就描述了遛狗的逻辑，即对应到函数定义，它是一个对应到设计的、静态的概念。
- 每项工作，最终需要人去做，人就对应到硬件：CPU/Core，是工作被完成的物质基础。

那什么是线程？某人做某项工作，比如张三在遛狗，那就对应一个线程，李四在扫地，则表示另一个线程在执行，可见线程是一个对应到执行的动态的概念。

但动态概念的线程，并不意味着某个线程会一直处于执行中，比如李四扫地过程中接到一个电话，李四需要去处理更紧急的事情（接电话），则扫地这个事情被挂起，李四打完电话后继续扫地，则这个线程会被继续执行。

那上面描述的情况，3项工作会对应几个线程呢？是不是3项工作就对应3个线程呢？答案：并不是。

比如有2个房间，让2个人去打扫，1个人打扫一个房间，那么就是2个线程；也可以1个人负责，一个房间接着一个房间的打扫，那么就是1个线程。

所以多线程并不一定需要多CPU多Core，即单CPU单Core系统依然可以运行多线程程序，虽然最大化利用多CPU多Core的处理能力是多线程程序设计的一个重要目标。

可以1个人把3项工作都做了，先遛狗、再扫地，然后做饭，显然1个人无法同时做多件事情，单CPU单Core也不行，操作系统通过时间分片技术应对远多于CPU数的多任务的挑战。

被调用函数执行完便返回调用该函数的地方，继续执行后面的语句，等到函数执行完再返回到它的调用函数，一步步返回到线程的入口函数，等到入口函数执行完成，线程的执行流程便结束了。

## 单核依然可以运行多线程程序
TODO

# 进程和线程
## 可执行程序
C/C++源文件经过编译器处理后，会产生可执行程序文件，比如Linux系统的ELF格式、Windows系统的EXE格式，可执行程序文件是一个静态的概念。

## 进程
可执行程序在操作系统上的一次执行对应一个进程，进程是一个动态的概念：执行中的程序。

同一份可执行文件执行多次，则会产生多个进程，这跟一个类可以实例化多个对象一样。

进程是资源分配的基本单位。

## 线程
一个进程内可以有多个线程，操作系统调度线程执行，而非进程。

每个进程有独立的地址空间，同一进程内的多个线程共享地址空间。

**协程**：用户层的多执行流。


# 什么是多线程？
一个进程内多个线程并发执行的情况就叫多线程，每个线程是一个独立的执行流。

单CPU单Core处理器也能运行多线程程序。

# 为什么需要多线程？
需要多线程的原因包括：
- 充分利用多核优势，加快执行速度
- 多线程影响程序编写方式

假设你要编写一个程序，用于统计一批文本文件的单词出现次数，程序的输入是文件名列表，输出一个单词到次数的映射。
```c++
// 类型别名：单词到次数的映射
using word2count = std::map<std::string, int>;

// 合并“单词到次数映射列表”
word2count merge(const std::vector<word2count>& w2c_list) {
    // TODO
}

// 统计一个文件里单词出现次数（单词到次数的映射）
word2count word_count_a_file(const std::string& file) {
    // TODO
}

// 统计一批文本文件的单词出现次数
word2count word_count(const std::vector<std::string>& files) {
    std::vector<word2count> w2c_list;
    for (auto &file : files) {
        w2c_list.push_back(word_count_a_file(file));
    }
    return merge(w2c_list);
}

int main(int argc, char* argv[]) {
    std::vector<std::string> files;
    for (int i = 1; i < argc; ++i) {
        files.push_back(argv[i]);
    }
    auto w2c = word_count(files);
    return 0;
}
```
这是一个单线程程序，`word_count(const std::vector<std::string>& files)`函数在主线程里被`main`函数调用。

如果文件不多、又或者每个文件不大，那么运行这个程序，很快就会得到统计结果。但如果文件数非常多、或者文件非常大，那么运行这个单线程程序可能要等很久才能返回结果。

重新审视这个程序，会发现：函数`word_count_a_file()`只接受一个文件名，它吐出从该文件计算出的局部结果，不依赖于其他外部数据和逻辑，它可以并发执行，所以，可以为每个文件启动一个单独的线程去运行`word_count_a_file()`，等到所有线程都执行完，再合并映射表得到最终结果。

当然，实际上，为每个文件启动一个线程未必合适，因为如果有数万个小文件，那么启动数万个线程，每个线程运行很短暂的时间，大量时间将耗费在线程创建和销毁上，并不是一个好的方案，一个改进的设计如下：
- 开启一个线程池，线程数等于Core数或二倍Core数。
- 每个工作线程去文件列表里取一个文件，然后统计这个文件的单词出现次数，如果文件列表为空，那么工作线程就退出。文件列表需要用锁保护起来。
- 所有工作线程退出后，在主线程里合并结果。

这样的多线程程序能加快处理速度，如果程序运行在多CPU多Core的机器上，就能充分利用多CPU多Core硬件优势，多线程加速执行是多线程的一个主要目的，此其一。

其二，有些场景会有阻塞的调用，如果不用多线程，那么逻辑不好写。

比如某程序在执行密集计算的同时，需要监控标准输入（键盘），如果键盘有输入，那么读取输入并解析执行，但如果获取键盘输入的调用是阻塞的，且键盘没有输入到来，那么其他逻辑将得不到执行。

针对这种情况，我们通常会开启一个单独的线程去接收输入，而用另一个线程去处理其他计算逻辑，避免处理输入阻塞其他逻辑处理，这也是需要多线程的典型应用。

# 怎么使用多线程？
待补充

## 线程编程接口
TODO

## 线程标识：pthread_self
TODO

## 线程创建：pthread_create
**线程入口函数**

## 线程终止：pthread_exit、pthread_cancel
TODO

## 线程交汇：pthread_join、pthread_detach
TODO

# 线程调度
TODO

## 时间分片
CPU先执行一段时间线程A，然后再执行一段时间线程B，然后再执行一段时间线程A，这就是CPU时间分片，时间分片是对调度策略的一个极度简化，实际上操作系统的调度策略非常精细，要比简单的时间分片复杂的多。如果一秒钟被分成大量的非常短的时间片，比如1000个1毫秒的时间片，一毫秒对人的感官而言太短了，以致于用户觉察不到延迟，仿佛计算机被该用户的任务所独占（实际上并不是），这要归功于计算机系统的进程的抽象。

## 上下文切换
把当前正在CPU上运行的任务迁走，并挑选一个新任务到CPU上执行的过程叫调度，任务调度的过程会发生上下文切换（context swap），即保存当前CPU上正在运行的线程状态，并恢复将要被执行的线程的状态，这个任务由操作系统完成，需要占用CPU时间（sys time）。

# 线程安全函数与可重入
代码所在的进程有多个线程在同时运行，这些线程可能在同时运行这些代码，如果多线程下运行的结果和单线程运行的结果是一样的，那么线程就是安全的。反之，线程就是不安全的。

不访问共享变量（包括全局变量、static local变量、成员变量），只操作参数，无副作用的函数才是线程安全函数，线程安全函数可多线程重入。

C标准库有很多编程接口都是非线程安全的，比如时间操作/转换相关的接口：ctime()/gmtime()/localtime()，c标准通过提供带_r后缀的线程安全版本，比如
```c++
char* ctime_r(const time* clock, char* buf);
```
这些接口的线程安全版本，一般都需要传递一个额外的char* buf参数，这样的话，函数会操作这块buf，而不是基于static共享数据，从而做到符合线程安全的要求。

# 线程私有数据
因为全局变量是进程内的所有线程共享的，但有时应用程序设计中必要提供线程私有的全局变量，这个变量仅在线程中有效，但却可以跨过多个函数访问。

比如在程序里可能需要每个线程维护一个链表，而会使用相同的函数来操作这个链表，最简单的方法就是使用同名而不同变量地址的线程相关数据结构。这样的数据结构可以由Posix线程库维护，成为线程私有数据 (Thread-specific Data，或称为 TSD)。

Posix线程私有数据相关接口：
- int pthread_key_create(pthread_key_t *key, void (*destructor)(void*));
- int pthread_key_delete(pthread_key_t key);
- int pthread_setspecific(pthread_key_t key, const void *value);
- void *pthread_getspecific(pthread_key_t key);

而C++等语言，提供threadlocal关键字，在语言层面支持。

# 阻塞和非阻塞
一个线程对应一个执行流，正常情况下，指令序列会被依次执行，计算逻辑会往前推进。但如果因为某种原因，一个线程的执行逻辑不能继续往前走，那么我们就说线程被阻塞住了。

线程阻塞的原因有很多种，比如：
- 线程**因为acquire某个锁**而被操作系统挂起，如果acquire睡眠锁失败，线程会让出CPU，操作系统会调度令一个可运行线程到该CPU上执行，线程被加入等待队列，进入睡眠状态。
- 线程**调用了某个阻塞系统调用**而等待，比如从没有数据到来的套接字上读数据，从空的消息队列里读消息。
- 线程**在循环里紧凑的执行测试&设置指令**并一直没有成功，虽然线程还在CPU上执行，但它只是忙等，相当于白白浪费CPU，后面的指令没法执行，逻辑同样无法推进。