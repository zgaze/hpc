# 线程的概念
线程是一个执行上下文，它包含诸多状态数据：每个线程有自己的调用栈、执行流、信号掩码、错误码、线程私有数据。Linux内核用任务（task）表示一个执行流。

## 执行流
一个任务里被依次执行的指令会形成一个指令序列（IP寄存器的值的历史记录），这个指令序列就是一个指令流，每个线程会有自己的执行流。

考虑下面的代码：
```c++
int calc(int a, int b, char op) {
  int c = 0;
  if (op == '+')
    c = a + b;
  else if (op == '-')
    c = a - b;
  else if (op == '*')
    c = a * b;
  else if (op == '/')
    c = a / b;
  else {
    printf("invalid operation\n");
  }
  return c;
}
```
`calc`函数会被编译成汇编指令，一行c代码不一定对应一个汇编指令（有可能是多个），在一个线程里执行`calc`，那么这些机器指令会被依次执行，但被执行的指令序列跟代码顺序可能不一致，因为代码中的条件分支、跳转、调用、返回等语句会影响执行路径。

## 逻辑线程 vs 硬件线程

### 逻辑线程
程序上的线程是一个逻辑上的概念，也叫任务、软线程、逻辑线程，任务这个词是很恰当的。

线程的执行逻辑由代码描述，比如编写一个函数实现对一个整型数组的元素求和：
```c++
int sum(int a[], int n) {
    int x = 0;
    for (int i = 0; i < n; ++i) 
        x += a[i];
    return x;
}
```
这个函数的逻辑很简单，它没有再调用其他函数。我们可以开一个线程去执行这个函数对某数组求和，也可以把`sum`设置为线程的入口函数，每个线程都会有一个入口函数，线程从入口函数开始执行。

函数描述了逻辑，即要做什么、以及怎么做，偏设计。但它没有描述物质，即没有描述这个事情由谁做，事情最终需要派发到实体去完成。

### 硬件线程
与逻辑线程对应的是硬件线程，这是逻辑线程被执行的物质基础。

芯片设计领域，一个硬件线程通常指为执行指令序列而配套的硬件单元，我们知道一个CPU可能有多个核心，然后有些核心还可以开2个超线程，这2个超线程复用一些硬件，但基本上可以认为是2个独立的执行单元。

一个软件线程由哪个CPU核心去执行、以及何时执行，则不归应用程序员管，它由操作系统决定，操作系统中的调度系统负责这项工作。

# 线程、核心、函数的关系
入口函数是线程的起点，线程从入口函数开始，一行代码接着一行代码执行，中间它可能会调用其他函数，那么它的控制流就转到了被调用的函数继续执行，被调用函数里还可以继续调用其他函数，这样便形成一个函数调用链。

前面的数组求和例子，如果数组特别大，则求和耗时长，那么，可以把这个整型数组分成多个小数组，或者表示成二维数组（数组的数组），每个线程负责一个小数组的求和，多个线程并发执行，最后再累加结果。所以，为了提升处理速度，可以让多个线程执行相同或者相似的计算逻辑。同样的处理逻辑可以有多个执行实例，即多个线程。

当然，也可以为两个线程指定不同的入口函数，让各线程执行不同的计算逻辑。

打个比方，假设有遛狗、扫地、做饭3项工作要做。

- 遛狗就是为狗系上绳子然后牵着它在小区里溜达一圈，这句话就描述了遛狗的逻辑，即对应到函数定义，它是一个对应到设计的、静态的概念。
- 每项工作，最终需要人去做，人就对应到硬件：CPU/Core，是工作被完成的物质基础。

那什么对应线程？某人做某项工作。
比如张三在遛狗，那就对应一个线程，李四在扫地，则表示另一个线程在执行，可见线程是一个对应到执行的动态的概念。

但动态概念的线程，并不意味着某个线程会一直处于执行中，比如李四扫地过程中接到一个电话，李四需要去处理更紧急的事情（接电话），则扫地这个事情被挂起，李四打完电话后继续扫地，则这个线程会被继续执行。

那上面描述的情况，3项工作会对应几个线程呢？是不是3项工作就对应3个线程呢？答案：并不是。

比如有2个房间，让2个人去打扫，1个人打扫一个房间，那么就是2个线程；也可以1个人负责，一个房间接着一个房间的打扫，那么就是1个线程。

所以多线程是一个编程模型，多线程并不一定需要多CPU多Core，即单CPU单Core系统依然可以运行多线程程序，虽然最大化利用多CPU多Core的处理能力是多线程程序设计的一个重要目标。

可以1个人把3项工作都做了，先遛狗、再扫地，然后做饭，显然1个人无法同时做多件事情，单CPU单Core也不行，操作系统通过时间分片技术应对远多于CPU数的多任务的挑战。

被调用函数执行完便返回调用该函数的地方，继续执行后面的语句，等到函数执行完再返回到它的调用函数，一步步返回到线程的入口函数，等到入口函数执行完成，线程的执行流程便结束了。

# 进程和线程
## 可执行程序
C/C++源文件经过编译器处理后，会产生可执行程序文件，比如Linux系统的ELF格式、Windows系统的EXE格式，可执行程序文件是一个静态的概念。

## 进程
可执行程序在操作系统上的一次执行对应一个进程，进程是一个动态的概念：执行中的程序。

同一份可执行文件执行多次，会产生多个进程，这跟一个类可以创建多个实例一样。

进程是资源分配的基本单位。

## 线程
一个进程内的多个线程代表着多个执行流，这些线程以并发模式独立执行。

操作系统中，被调度执行的最小单位是线程，而不是进程。

进程是通过共享存储空间对用户呈现的概念。同一进程内的多个线程共享地址空间和文件描述符，共享地址空间意味着进程的代码区域（函数）、全局变量、堆、栈都被进程内的多线程共享。

## 进程和线程的关系
先看看linus的论述，在96年的一封邮件里，linus详细解释了他对进程和线程关系的理解，非常富有洞见，他认为：
- 把进程和线程区分为不同的实体是背着历史包袱的**传统**做法，没有必要做这样的区分，甚至这样的思考方式是一个主要错误。
- 进程和线程都是一回事：一个执行上下文（context of execution），简称为COE，其状态包括：
    - CPU状态（寄存器等）
    - MMU状态（页映射）
    - 权限状态（uid、gid等）
    - 各种通信状态（打开的文件、信号处理器等）
- 传统认为：进程和线程的主要区别是线程有CPU状态（可能还包括其他最小必要状态），而其他上下文来自进程。然而，这种区分法并不正确，这是一种愚蠢的自我设限。
- linux内核认为根本没有所谓的进程和线程的概念，只有COE（Linux称之为任务），不同的COE可以相互共享一些状态，通过这类共享构建起进程和线程的概念。
- 简言之，内核不要基于进程/线程的概念做设计，而应该围绕COE的思考方式做设计，然后，通过暴露有限的接口给用户去满足`pthreads`库的要求。

## 协程
用户层的多执行流。

# 什么是多线程？
一个进程内多个线程并发执行的情况就叫多线程，每个线程是一个独立的执行流，多线程是一种编程模型，它与处理器无关，单CPU单Core处理器也能运行多线程程序。

# 为什么需要多线程？
需要多线程的原因包括：
- 充分利用多核，提升整体吞吐，加快执行速度
- 多线程能简化程序编写

## 通过多线程并发提升处理能力
假设你要编写一个程序，用于统计一批文本文件的单词出现次数，程序的输入是文件名列表，输出一个单词到次数的映射。
```c++
// 类型别名：单词到次数的映射
using word2count = std::map<std::string, int>;

// 合并“单词到次数映射列表”
word2count merge(const std::vector<word2count>& w2c_list) {
    // TODO
}

// 统计一个文件里单词出现次数（单词到次数的映射）
word2count word_count_a_file(const std::string& file) {
    // TODO
}

// 统计一批文本文件的单词出现次数
word2count word_count_files(const std::vector<std::string>& files) {
    std::vector<word2count> w2c_list;
    for (auto &file : files) {
        w2c_list.push_back(word_count_a_file(file));
    }
    return merge(w2c_list);
}

int main(int argc, char* argv[]) {
    std::vector<std::string> files;
    for (int i = 1; i < argc; ++i) {
        files.push_back(argv[i]);
    }
    auto w2c = word_count_files(files);
    return 0;
}
```
这是一个单线程程序，`word_count_files(const std::vector<std::string>& files)`函数在主线程里被`main`函数调用。

如果文件不多、又或者文件不大，那么运行这个程序，很快就会得到统计结果，否则，可能要等很久才能返回结果。

重新审视这个程序会发现：函数`word_count_a_file()`接受一个文件名，吐出从该文件计算出的局部结果，它不依赖于其他外部数据和逻辑，可以并发执行，所以，可以为每个文件启动一个单独的线程去运行`word_count_a_file()`，等到所有线程都执行完，再合并映射表得到最终结果。

实际上，为每个文件启动一个线程未必合适，因为如果有数万个小文件，那么启动数万个线程，每个线程运行很短暂的时间，大量时间将耗费在线程创建和销毁上，一个改进的设计如下：
- 开启一个线程池，线程数等于Core数或二倍Core数。
- 每个工作线程尝试去文件列表（文件列表需要用锁保护起来）里取一个文件。
    - 成功，统计这个文件的单词出现次数。
    - 失败，工作线程就退出。
- 待所有工作线程退出后，在主线程里合并结果。

这样的多线程程序能加快处理速度，前面数组求和可以采用相似的处理，如果程序运行在多CPU多Core的机器上，就能充分利用多CPU多Core硬件优势，多线程加速执行是多线程的一个主要目的，此其一。

## 多线程简化程序编写
其二，有些场景会有阻塞的调用，如果不用多线程，那么逻辑不好写。

比如某程序在执行密集计算的同时，需要监控标准输入（键盘），如果键盘有输入，那么读取输入并解析执行，但如果获取键盘输入的调用是阻塞的，且键盘没有输入到来，那么其他逻辑将得不到执行。

针对这种情况，我们通常会开启一个单独的线程去接收输入，而用另一个线程去处理其他计算逻辑，避免处理输入阻塞其他逻辑处理，这也是需要多线程的典型应用。

# 怎么使用多线程？

## 线程编程接口
目前，各主流编程语言都提供多线程编程支持，比如：
- C语言的11标准提供了并发支持库，主要API包括：
    - `thrd_create`         创建线程
    - `thrd_yield`          让出CPU
    - `thrd_exit`           退出线程
    - `thrd_current`        获取当前线程标识
    - `thrd_join`           等待某个线程退出
- C++也在11标准提供了并发支持库，提供了：
    - `thread`              线程类
    - `atomic<T>`           原子变量
    - `mutex`               互斥锁
    - `condition_variable`  条件变量

POSIX是开发操作系统互联标准，POSIX.1-2001定义了线程相关的接口`POXIS threads`，这些接口也叫`pthreads`，可以通过`_POSIX_THREADS`宏去测试系统是否支持`pthreads`。

本文主要介绍`pthreads`，相关接口都以`pthread_`作为前缀，要使用这些接口，需要包含头文件：`#include <pthread.h>`

## 线程标识：pthread_self
```c
pthread_t pthread_self(void);
```
`pthread_self`返回调用线程的标识，这个调用总是成功。

`pthread_t`是一个对用户而言不透明的类型，反正用来区分线程的身份，不能简单假设它是一个整型。

线程ID是进程域内，进程内的多个线程会有唯一ID，而进程ID是操作系统范围内唯一。

```c
int pthread_equal(pthread_t tid1, pthread_t tid2);
```
线程标识判等，相等非0，不等返回0.

## 线程创建：pthread_create
```c
int pthread_create(pthread_t *restrict tidp, const pthread_attr_t *restrict attr, void *(*start_rtn)(void *), void *restrict arg);
```
参数：
- tidp用于接受新创建的线程标识
- attr是线程属性
- start_rtn是**线程入口函数**，这个参数最重要
- arg是传入线程入口函数的参数

返回值：0表示成功；非0表示失败，返回值是错误码

## 线程终止：pthread_exit、pthread_cancel
```c
void pthread_exit(void *rval_ptr);                         // 调用线程主动退出
int pthread_cancel(pthread_t tid);                         // 让别的线程（tid）退出，默认tid线程会退出，实际上，tid线程可以忽视这个要求
```

## 线程交汇：pthread_join、pthread_detach
```c
int pthread_join(pthread_t thread, void **rval_ptr);       // 等待thread退出，并把退出码存入rval_ptr
int pthread_detach(pthread_t tid);                         // 把线程至于分离状态
```

# 线程调度

## 时间分片
CPU先执行一段时间线程A，然后再执行一段时间线程B，然后再执行一段时间线程A，这就是CPU时间分片，时间分片是对调度策略的一个极度简化，实际上操作系统的调度策略非常精细，要比简单的时间分片复杂的多。如果一秒钟被分成大量的非常短的时间片，比如1000个1毫秒的时间片，一毫秒对人的感官而言太短了，以致于用户觉察不到延迟，仿佛计算机被该用户的任务所独占（实际上并不是），这要归功于计算机系统的进程的抽象。

## 上下文切换
把当前正在CPU上运行的任务迁走，并挑选一个新任务到CPU上执行的过程叫调度，任务调度的过程会发生上下文切换（context swap），即保存当前CPU上正在运行的线程状态，并恢复将要被执行的线程的状态，这个任务由操作系统完成，需要占用CPU时间（sys time）。

# 线程安全函数与可重入
代码所在的进程有多个线程在同时运行，这些线程可能在同时运行这些代码，如果多线程下运行的结果和单线程运行的结果是一样的，那么线程就是安全的。反之，线程就是不安全的。

不访问共享变量（包括全局变量、static local变量、成员变量），只操作参数，无副作用的函数才是线程安全函数，线程安全函数可多线程重入。

C标准库有很多编程接口都是非线程安全的，比如时间操作/转换相关的接口：ctime()/gmtime()/localtime()，c标准通过提供带_r后缀的线程安全版本，比如
```c++
char* ctime_r(const time* clock, char* buf);
```
这些接口的线程安全版本，一般都需要传递一个额外的char* buf参数，这样的话，函数会操作这块buf，而不是基于static共享数据，从而做到符合线程安全的要求。

# 线程私有数据
因为全局变量是进程内的所有线程共享的，但有时应用程序设计中必要提供线程私有的全局变量，这个变量仅在线程中有效，但却可以跨过多个函数访问。

比如在程序里可能需要每个线程维护一个链表，而会使用相同的函数来操作这个链表，最简单的方法就是使用同名而不同变量地址的线程相关数据结构。这样的数据结构可以由Posix线程库维护，成为线程私有数据 (Thread-specific Data，或称为 TSD)。

Posix线程私有数据相关接口：
```c
int pthread_key_create(pthread_key_t *key, void (*destructor)(void*));

int pthread_key_delete(pthread_key_t key);

int pthread_setspecific(pthread_key_t key, const void *value);

void *pthread_getspecific(pthread_key_t key);
```
而C++等语言，提供threadlocal关键字，在语言层面支持。

# 阻塞和非阻塞
一个线程对应一个执行流，正常情况下，指令序列会被依次执行，计算逻辑会往前推进。但如果因为某种原因，一个线程的执行逻辑不能继续往前走，那么我们就说线程被阻塞住了。

线程阻塞的原因有很多种，比如：
- 线程**因为acquire某个锁**而被操作系统挂起，如果acquire睡眠锁失败，线程会让出CPU，操作系统会调度令一个可运行线程到该CPU上执行，线程被加入等待队列，进入睡眠状态。
- 线程**调用了某个阻塞系统调用**而等待，比如从没有数据到来的套接字上读数据，从空的消息队列里读消息。
- 线程**在循环里紧凑的执行测试&设置指令**并一直没有成功，虽然线程还在CPU上执行，但它只是忙等，相当于白白浪费CPU，后面的指令没法执行，逻辑同样无法推进。