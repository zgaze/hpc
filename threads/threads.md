# 引言

在十多年前，主流观点主张在可能的情况下优先选择多进程而非多线程。然而，时至今日，多线程编程已经成为编程领域的事实标准。多线程技术在很大程度上改善了程序的性能和响应能力，使其能够更加高效地利用系统资源。这不仅归功于多核处理器的普及和软硬件技术的进步，还归功于开发者们对多线程编程的深入理解和技术创新。
# 线程的概念

线程是一个执行上下文，它包含诸多状态数据：每个线程有自己的执行流、调用栈、错误码、信号掩码、私有数据。Linux内核用任务（task）表示一个执行流。

## 执行流
一个任务里被依次执行的指令会形成一个指令序列（IP寄存器的值的历史记录），这个指令序列就是一个指令流，每个线程会有自己的执行流。

考虑下面的代码：
```c++
int calc(int a, int b, char op) {
  int c = 0;
  if (op == '+')
    c = a + b;
  else if (op == '-')
    c = a - b;
  else if (op == '*')
    c = a * b;
  else if (op == '/')
    c = a / b;
  else {
    printf("invalid operation\n");
  }
  return c;
}
```
`calc`函数被编译成汇编指令，一行c代码对应一个或多个汇编指令，在一个线程里执行`calc`，那么这些机器指令会被依次执行。

但是，被执行的指令序列跟代码顺序可能不完全一致，代码中的条件、跳转等语句，以及编译器对指令重排、处理器乱序执行会影响指令的真正执行顺序。

## 逻辑线程 vs 硬件线程

### 逻辑线程
程序上的线程是一个逻辑上的概念，也叫任务、软线程、逻辑线程。

线程的执行逻辑由代码描述，比如编写一个函数实现对一个整型数组的元素求和：
```c++
int sum(int a[], int n) {
    int x = 0;
    for (int i = 0; i < n; ++i) 
        x += a[i];
    return x;
}
```
这个函数的逻辑很简单，它没有再调用其他函数。

我们可以开一个线程去调用这个函数对某数组求和，也可以把`sum`设置为线程的入口函数，每个线程都会有一个入口函数，线程从入口函数开始执行。

`sum`函数描述了逻辑，即要做什么、以及怎么做，偏设计；但它没有描述物质，即没有描述这个事情由谁做，事情最终需要派发到实体去完成。

### 硬件线程
与逻辑线程对应的是硬件线程，这是逻辑线程被执行的物质基础。

芯片设计领域，一个硬件线程通常指为执行指令序列而配套的硬件单元，一个CPU可能有多个核心，然后核心还可能支持超线程，1个核心的2个超线程复用一些硬件。

从软件的视角来看，无须区分是真正的core和超出来的vcore，基本上可以认为是2个独立的执行单元。

一个软件线程由哪个CPU/核心去执行、以及何时执行，则不归应用程序员管，它由操作系统决定，操作系统中的调度系统负责这项工作。

# 线程、核心、函数的关系
入口函数是线程的起点，线程从入口函数开始，一行代码接着一行代码执行，中间它可能会调用其他函数，那么它的控制流就转到了被调用的函数继续执行，被调用函数里还可以继续调用其他函数，这样便形成一个函数调用链。

前面的数组求和例子，如果数组特别大，则哪怕是一个简单的循环累加也可能耗费很长的时间，可以把这个整型数组分成多个小数组，或者表示成二维数组（数组的数组），每个线程负责一个小数组的求和，多个线程并发执行，最后再累加结果。

所以，为了提升处理速度，可以让多个线程执行相同或者相似的计算逻辑，同样的处理逻辑可以有多个执行实例，即多个线程。

当然，也可以为两个线程指定不同的入口函数，让各线程执行不同的计算逻辑。

我们用一个例子来阐述线程、核心和函数之间的关系，假设有遛狗、扫地2类工作要做。
- 遛狗就是为狗系上绳子然后牵着它在小区里溜达一圈，这句话就描述了遛狗的逻辑，即对应到函数定义，它是一个对应到设计的、静态的概念。
- 每项工作，最终需要人去做，人就对应到硬件：CPU/Core/VCore，是任务被完成的物质基础。

那什么对应（软件）线程？任务拆分。

假设现在有2条狗需要遛、3个房间需要打扫。

可以把遛狗拆成2个任务，一个任务是遛小狗，另一个任务是遛大狗；打扫房间拆分为3个任务，一个任务对应一个房间，执行这样的拆分策略后，就会产生`2+3=5`个任务。

但如果只有2个人，2个人无法同时做5个事，让某人在某时干某事由调度系统负责。

如果张三在遛小狗，那就对应一个线程被执行，李四在扫房间A，则表示另一个线程在执行中，可见线程是一个动态的概念。

软件线程不会一直处于执行中，原因是多方面的。上述例子是因为人手不够，所以遛大狗的任务还处于等待被执行的状态，其他的原因包括中断、抢占、条件依赖等，比如李四扫地过程中接到一个电话，李四需要去处理更紧急的事情（接电话），则扫地这个事情被挂起，李四打完电话后继续扫地，则这个线程会被继续执行。

如果只有1个人，则上述5个任务依然可以被依次或交错完成，而人对应到硬件核心，所以多线程是一个编程模型，多线程并不一定需要多CPU多Core，单CPU单Core系统依然可以运行多线程程序（虽然最大化利用多CPU多Core的处理能力是多线程程序设计的一个重要目标）。

1个人无法同时做多项任务，单CPU/单Core也不可以，操作系统通过时间分片技术应对远多于CPU/Core数的多任务执行的挑战。

也可以把有些任务只分配给某些人去完成，这对应到cpu亲和性和绑核。

# 进程和线程
## 可执行程序
C/C++源文件经过编译器处理后，会产生可执行程序文件，不同系统有不同格式，比如Linux系统的ELF格式、Windows系统的EXE格式，可执行程序文件是一个静态的概念。

## 进程
可执行程序在操作系统上的一次执行对应一个进程，进程是一个动态的概念：进程是执行中的程序。

同一份可执行文件执行多次，会产生多个进程，这跟一个类可以创建多个实例一样。

进程是资源分配的基本单位。

## 线程
一个进程内的多个线程代表着多个执行流，这些线程以并发模式独立执行。

操作系统中，被调度执行的最小单位是线程，而不是进程。

进程是通过共享存储空间对用户呈现的概念。同一进程内的多个线程共享地址空间和文件描述符，共享地址空间意味着进程的代码（函数）区域、全局变量、堆、栈都被进程内的多线程共享。

## 进程和线程的关系
先看看linus的论述，在96年的一封邮件里，linus详细阐述了他对进程和线程关系的深刻洞见，他写道：
- 把进程和线程区分为不同的实体是背着历史包袱的传统做法，没有必要做这样的区分，甚至这样的思考方式是一个主要错误。
- 进程和线程都是一回事：一个执行上下文（context of execution），简称为COE，其状态包括：
    - CPU状态（寄存器等）
    - MMU状态（页映射）
    - 权限状态（uid、gid等）
    - 各种通信状态（打开的文件、信号处理器等）
- 传统观念认为：进程和线程的主要区别是线程有CPU状态（可能还包括其他最小必要状态），而其他上下文来自进程；然而，这种区分法并不正确，这是一种愚蠢的自我设限。
- linux内核认为根本没有所谓的进程和线程的概念，只有COE（Linux称之为任务），不同的COE可以相互共享一些状态，通过此类共享向上构建起进程和线程的概念。
- 从实现来看，Linux下的线程目前是LWP实现，线程就是轻量级进程，所有的线程都当作进程来实现，因此线程和进程都是用task_struct来描述的。这一点通过/proc文件系统也能看出端倪，线程和进程拥有比较平等的地位。对于多线程来说，原本的进程称为主线程，它们在一起组成一个线程组。
- 简言之，内核不要基于进程/线程的概念做设计，而应该围绕COE的思考方式去做设计，然后，通过暴露有限的接口给用户去满足`pthreads`库的要求。

## 协程
用户层的多执行流，上下文切换成本比线程更低，微信用协程改造后台系统后，获得了更强的吞吐能力和稳定性，如今，协程库也进了C++新标准。

# 什么是多线程？
一个进程内多个线程并发执行的情况就叫多线程，每个线程是一个独立的执行流，多线程是一种编程模型，它与处理器无关，它跟设计有关。

# 为什么需要多线程？
需要多线程的原因包括：
- **并行计算**：充分利用多核，提升整体吞吐，加快执行速度
- **后台任务处理**：将后台线程和主线程分离，在特定场景它是不可缺少的，如：响应式用户界面、实时系统等。

## 通过多线程并发提升处理能力
假设你要编写一个程序，用于统计一批文本文件的单词出现次数，程序的输入是文件名列表，输出一个单词到次数的映射。
```c++
// 类型别名：单词到次数的映射
using word2count = std::map<std::string, int>;

// 合并“单词到次数映射列表”
word2count merge(const std::vector<word2count>& w2c_list) {
    // TODO
}

// 统计一个文件里单词出现次数（单词到次数的映射）
word2count word_count_a_file(const std::string& file) {
    // TODO
}

// 统计一批文本文件的单词出现次数
word2count word_count_files(const std::vector<std::string>& files) {
    std::vector<word2count> w2c_list;
    for (auto &file : files) {
        w2c_list.push_back(word_count_a_file(file));
    }
    return merge(w2c_list);
}

int main(int argc, char* argv[]) {
    std::vector<std::string> files;
    for (int i = 1; i < argc; ++i) {
        files.push_back(argv[i]);
    }
    auto w2c = word_count_files(files);
    return 0;
}
```
这是一个单线程程序，`word_count_files(const std::vector<std::string>& files)`函数在主线程里被`main`函数调用。

如果文件不多、又或者文件不大，那么运行这个程序，很快就会得到统计结果，否则，可能要等许久才能返回结果。

重新审视这个程序会发现：函数`word_count_a_file()`接受一个文件名，吐出从该文件计算出的局部结果，它不依赖于其他外部数据和逻辑，可以并发执行，所以，可以为每个文件启动一个单独的线程去运行`word_count_a_file()`，等到所有线程都执行完，再合并得到最终结果。

实际上，为每个文件启动一个线程未必合适，因为如果有数万个小文件，那么启动数万个线程，每个线程运行很短暂的时间，大量时间将耗费在线程创建和销毁上，一个改进的设计：
- 开启一个线程池，线程数等于Core数或二倍Core数。
- 每个工作线程尝试去文件列表（文件列表需要用锁保护起来）里取一个文件。
    - 成功，统计这个文件的单词出现次数。
    - 失败，该工作线程就退出。
- 待所有工作线程退出后，在主线程里合并结果。

这样的多线程程序能加快处理速度，前面数组求和可以采用相似的处理，如果程序运行在多CPU多Core的机器上，就能充分利用多CPU多Core硬件优势，多线程加速执行是多线程的一个显而易见的主要目的，此其一。

## 后台任务处理
其二，有些场景会有阻塞的调用，如果不用多线程，那么逻辑不好写。

比如某程序在执行密集计算的同时，需要监控标准输入（键盘），如果键盘有输入，那么读取输入并解析执行，但如果获取键盘输入的调用是阻塞的，而此时键盘没有输入到来，那么其他逻辑将得不到机会执行。

代码看起来会像下面这样子：
```C++
// getComandFromStdInput会从键盘接收输入，经解释后，会构建一个Command对象返回
Command command = getComandFromStdInput();
// 执行命令
command.run();
```

针对这种情况，我们通常会开启一个单独的线程去接收输入，而用另一个线程去处理其他计算逻辑，避免处理输入阻塞其他逻辑处理，这也是多线程的典型应用，它改变了程序的编写方式。

# 怎么使用多线程？

## 线程编程接口
目前，各主流编程语言都提供多线程编程支持，比如：
- C语言的11标准提供了并发支持库，主要API包括：
    - `thrd_create`         创建线程
    - `thrd_yield`          让出CPU
    - `thrd_exit`           退出线程
    - `thrd_current`        获取当前线程标识
    - `thrd_join`           等待某个线程退出
- C++也在11标准提供了并发支持库，提供了：
    - `thread`              线程类
    - `atomic<T>`           原子变量
    - `mutex`               互斥锁
    - `condition_variable`  条件变量

POSIX是开放操作系统互联标准，POSIX.1-2001定义了线程相关的接口`POXIS threads`，这些接口也叫`pthreads`，可以通过`_POSIX_THREADS`宏去测试系统是否支持`pthreads`。

本文主要介绍`pthreads`，相关接口都以`pthread_`作为前缀，掌握`pthreads`编程接口后，语言相关的编程接口便也触类旁通。

要使用这些接口，需要包含头文件：`#include <pthread.h>`，用`gcc/g++`链接程序的时候，需要加`-pthread`。

这些接口并不复杂，这里只是简单介绍一下：

## 线程标识：pthread_self
```c
pthread_t pthread_self(void);
```
`pthread_self`返回调用线程的标识，这个调用总是成功。
`pthread_t`是一个对用户而言不透明的类型，反正用来区分线程的身份，不能简单假设它是一个整型。

线程ID是进程域内，进程内的多个线程会有唯一ID，而进程ID是操作系统范围内唯一。

```c
int pthread_equal(pthread_t tid1, pthread_t tid2);
```
线程标识判等，相等非0，不等返回0.

## 线程创建：pthread_create
```c
int pthread_create(pthread_t *restrict tidp, const pthread_attr_t *restrict attr, void *(*start_rtn)(void *), void *restrict arg);
```
参数：
- tidp用于接受新创建的线程标识
- attr是线程属性
- start_rtn是线程入口函数，重要
- arg是传入线程入口函数的参数

返回值：0表示成功；非0表示失败，返回值是错误码

## 线程终止：pthread_exit、pthread_cancel
```c
void pthread_exit(void *rval_ptr);                         // 调用线程主动退出
int pthread_cancel(pthread_t tid);                         // 让别的线程（tid）退出，默认tid线程会退出，实际上，tid线程可以忽视这个要求
```

## 线程交汇：pthread_join、pthread_detach
```c
int pthread_join(pthread_t thread, void **rval_ptr);       // 等待thread退出，并把退出码存入rval_ptr
int pthread_detach(pthread_t tid);                         // 把线程至于分离状态
```

# 线程调度

## 时间分片
CPU先执行一段时间线程A，然后再执行一段时间线程B，然后再执行一段时间线程A，这就是CPU时间分片。

时间分片是对调度策略的一个极度简化，实际上操作系统的调度策略非常精细，要比简单的时间分片复杂的多。

如果一秒钟被分成大量的非常短的时间片，比如1000个1毫秒的时间片，一毫秒对人的感官而言太短了，以致于用户觉察不到延迟，仿佛计算机被该用户的任务所独占（实际上并不是），操作系统通过进程的抽象获得了这种效果。

## 上下文切换
把当前正在CPU上运行的任务迁走，并挑选一个新任务到CPU上执行的过程叫调度，任务调度的过程会发生上下文切换（context swap），即保存当前CPU上正在运行的线程状态，并恢复将要被执行的线程的状态，这个任务由操作系统完成，需要占用CPU时间（sys time）。

# 线程安全函数与可重入
代码所在的进程有多个线程在同时运行，这些线程可能在同时运行这些代码，如果多线程下运行的结果和单线程运行的结果是一样的，那么线程就是安全的。反之，线程就是不安全的。

不访问共享变量（包括全局变量、static local变量、成员变量），只操作参数，无副作用的函数才是线程安全函数，线程安全函数可多线程重入。

C标准库有很多编程接口都是非线程安全的，比如时间操作/转换相关的接口：ctime()/gmtime()/localtime()，c标准通过提供带_r后缀的线程安全版本，比如
```c++
char* ctime_r(const time* clock, char* buf);
```
这些接口的线程安全版本，一般都需要传递一个额外的char* buf参数，这样的话，函数会操作这块buf，而不是基于static共享数据，从而做到符合线程安全的要求。

# 线程私有数据
因为全局变量是进程内的所有线程共享的，但有时应用程序设计中必要提供线程私有的全局变量，这个变量仅在线程中有效，但却可以跨过多个函数访问。

比如在程序里可能需要每个线程维护一个链表，而会使用相同的函数来操作这个链表，最简单的方法就是使用同名而不同变量地址的线程相关数据结构。这样的数据结构可以由Posix线程库维护，成为线程私有数据 (Thread-specific Data，或称为 TSD)。

Posix线程私有数据相关接口：
```c
int pthread_key_create(pthread_key_t *key, void (*destructor)(void*));

int pthread_key_delete(pthread_key_t key);

int pthread_setspecific(pthread_key_t key, const void *value);

void *pthread_getspecific(pthread_key_t key);
```
而C++等语言，提供threadlocal关键字，在语言层面支持。

# 阻塞和非阻塞
一个线程对应一个执行流，正常情况下，指令序列会被依次执行，计算逻辑会往前推进。但如果因为某种原因，一个线程的执行逻辑不能继续往前走，那么我们就说线程被阻塞住了。

就像你下班回家，但走到家门口发现没带钥匙，你在门口徘徊，任由时间流逝。

线程阻塞的原因有很多种，比如：
- 线程**因为acquire某个锁**而被操作系统挂起，如果acquire睡眠锁失败，线程会让出CPU，操作系统会调度另一个可运行线程到该CPU上执行，线程会被加入等待队列，进入睡眠状态。
- 线程**调用了某个阻塞系统调用**而等待，比如从没有数据到来的套接字上读数据，从空的消息队列里读消息。
- 线程**在循环里紧凑的执行测试&设置指令**并一直没有成功，虽然线程还在CPU上执行，但它只是忙等，相当于白白浪费CPU，后面的指令没法执行，逻辑同样无法推进。

如果某个系统调用或者编程接口有可能导致线程阻塞，那么便被称之为阻塞系统调用，与之对应的是非阻塞调用，调用这样的函数不会陷入阻塞，如果请求的资源不能得到满足，它会立即返回并通过返回值或错误码报告原因，调用的地方可以选择重试或者返回。