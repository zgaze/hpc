# 多线程

## 进程和线程

C/C++源文件经过编译器处理后，会产生可执行程序文件，可执行程序文件是一个静态的概念。可执行程序在操作系统上的一次执行则对应一个进程，进程是一个动态的概念，同一份可执行文件执行多次，则会产生多个进程实体。

线程是最小执行单元、是操作系统中被调度执行的最小单位，即操作系统调度线程执行，而非进程。

一个进程内可以有多个线程，每个进程有独立的地址空间，同一进程内的多个线程共享地址空间。

## 堆栈

每个线程都会有一个入口函数，线程从入口函数开始执行，一行代码接着一行代码执行，中间它可能会调用其他函数，那么它的控制流就转到了被调用的函数继续执行，被调用函数里还可以继续调用其他函数，这样便形成一个函数调用链。

被调用函数执行完便返回调用该函数的地方，继续执行后面的语句，等到函数执行完再返回到它的调用函数，一步步返回到线程的入口函数，等到入口函数执行完成，线程的执行流程便结束了。

假设某线程的入口函数是a，a函数里调用了b，b函数里调用了c，那么调用链是：a() -> b() -> c()；c函数执行完返回b，b函数执行完返回a，所以返回链是调用链的逆序：c() -> b() -> a()。

线程在执行过程中，每个被调用的函数会对应到一帧（Frame），每帧会有一个帧编号，当前正被执行的函数对应的帧号为0，调用它的函数对应的帧号为1，多个帧形成调用堆栈，栈帧反映函数调用关系，每个线程有独立的调用堆栈，两个特殊的寄存器用于界定当前帧的顶和底，之前的栈帧信息被保存在栈内存里，函数内的局部变量也保存在该线程私有的栈内存里。

当b函数被调用执行时，栈的深度是2，c函数被执行时，帧的深度是3，当c函数被执行完，返回到b函数里调用c的地方，栈的深度又变成了2，当b函数执行完，返回a，栈的深度就变成了1，可见调用堆栈是动态伸缩的，每个线程的栈内存很小，只有几兆，过深的递归、函数内定义过大局部变量（通常是大的数组）会有爆栈的风险。

## 执行流

一个线程里被执行的代码行会被编译成汇编指令，所以，依次执行的代码，会转变为一个被一次执行的指令序列，这个指令序列就是执行流，一个执行流对应一个线程，多个执行流并发执行的情况就叫多线程程序。

注意：这个指令序列跟代码顺序不一样，代码中的条件分支和跳转返回语句等会影响执行流。

## 逻辑线程和硬件线程

线程的执行逻辑由代码描述，比如编写一个函数实现对一个整型数组的元素求和：
```c++
int Sum(int a[], int n) {
    int x = 0;
    for (int i = 0; i < n; ++i) {
        x += a[i];
    }
    return x;
}
```
这个函数逻辑很简单，它没有再调用其他函数，我们可以开一个线程去执行这个函数对某数组求和。

函数描述了逻辑，即要做什么、以及怎么做，它偏设计，它没有描述物质，即没有描述这个事情由谁做，事情最终需要派发到实体去完成。

程序上的线程是一个逻辑上的概念，也叫任务、软线程、逻辑线程；需要跟芯片的线程概念做区分，芯片上的线程的概念，通常指为执行指令序列而配套的硬件单元，所以也叫硬线程。

一个软件线程由哪个CPU核心去执行、以及何时执行，则不归应用程序员管，它由操作系统决定，操作系统中的调度系统负责这项工作。

## 函数、线程和核的关系

数组求和例子，如果数组特别大，则求和耗时长，那么，可以把这个整型数组分成多个小数组，或者表示成二维数组（数组的数组），每个线程负责一个小数组的求和，多个线程并发执行，最后再累加结果。所以，为了提升处理速度，可以让多个线程执行相同或者相似的计算逻辑。同样的处理逻辑可以有多个执行实例，即多个线程。

当然，也可以为两个线程指定不同的入口函数，让各线程执行不同的计算逻辑。

打个比方，假设有遛狗、扫地、做饭3项工作要做。

- 遛狗就是为狗系上绳子然后牵着它在小区里溜达一圈，这句话就描述了遛狗的逻辑，即对应到函数定义，它是一个对应到设计的、静态的概念。
- 每项工作，最终需要人去做，人就对应到硬件：CPU/Core，是工作被完成的物质基础。

那什么是线程？某人做某项工作，比如张三在遛狗，那就对应一个线程，李四在扫地，则表示另一个线程在执行，可见线程是一个对应到执行的动态的概念。

但动态概念的线程，并不意味着某个线程会一直处于执行中，比如李四扫地过程中接到一个电话，李四需要去处理更紧急的事情（接电话），则扫地这个事情被挂起，李四打完电话后继续扫地，则这个线程会被继续执行。

那上面描述的情况，3项工作会对应几个线程呢？是不是3项工作就对应3个线程呢？答案：并不是。

比如有2个房间，让2个人去打扫，1个人打扫一个房间，那么就是2个线程；也可以1个人负责，一个房间接着一个房间的打扫，那么就是1个线程。

所以多线程并不一定需要多CPU多Core，即单CPU单Core系统依然可以运行多线程程序，虽然最大化利用多CPU多Core的处理能力是多线程程序设计的一个重要目标。

可以1个人把3项工作都做了，先遛狗、再扫地，然后做饭，显然1个人无法同时做多件事情，单CPU单Core也不行，操作系统通过时间分片技术应对远多于CPU数的多任务的挑战。

## 时间分片

CPU先执行一段时间线程A，然后再执行一段时间线程B，然后再执行一段时间线程A，这就是CPU时间分片，时间分片是对调度策略的一个极度简化，实际上操作系统的调度策略非常精细，要比简单的时间分片复杂的多。如果一秒钟被分成大量的非常短的时间片，比如1000个1毫秒的时间片，一毫秒对人的感官而言太短了，以致于用户觉察不到延迟，仿佛计算机被该用户的任务所独占（实际上并不是），这要归功于计算机系统的进程的抽象。

## 上下文切换

把当前正在CPU上运行的任务迁走，并挑选一个新任务到CPU上执行的过程叫调度，任务调度的过程会发生上下文切换（context swap），即保存当前CPU上正在运行的线程状态，并恢复将要被执行的线程的状态，这个任务由操作系统完成，需要占用CPU时间（sys time）。

- 并发：多个任务被交错执行的情况被称为多任务（线程）并发；如果一个任务的开始时间，不晚于另一个任务的结束时间，那么这2个任务就是并发执行的。
- 并行：如果多个任务在多个CPU或者多核上同时执行，齐头并进，则称为多任务并行，并行可以发生在单机多线程，也可以发生在分布式多机环境。

## 多线程同步

因为进程内的多个线程共享地址空间，所以多线程之间需要同步，避免因为多线程对数据的并发访问而出错。