# 多线程

线程是操作系统中被调度执行的最小单位，一个线程就是一个执行流，一个执行流就是一个被依次执行的指令序列。

## 堆栈

每个线程都会有一个入口函数，线程执行从入口函数开始，一行代码接着一行代码执行，中间它可能会调用其他函数，那么它的控制流就转到了被调用的函数继续执行，被调用函数里也可以调用其他函数，这样便形成一个函数调用链，被调用函数执行完便返回调用该函数的地方，继续执行后面的语句，函数执行完再返回到它的调用函数，一步步的返回到线程的入口函数，等到入口函数执行完成，线程的执行流程便完成了。

假设某线程的入口函数是a，a函数里调用了b，b函数里调用了c，那么调用链是：a() -> b() -> c()。线程在执行过程中，每个被调用的函数会对应到一帧（Frame），多个帧形成调用堆栈，栈帧反映函数调用关系，每个线程有一个调用堆栈。

当b函数被调用时，栈的深度是2，c函数被执行时，帧的深度是3，当c函数被执行完，便返回到b函数里调用c的地方，栈的深度又变成了2，当b函数执行完，便返回a，栈的深度就变成了1，可见调用栈是动态伸缩的，返回的过程是：c() -> b() -> a()。

被执行的代码行会被编译成汇编指令，所以，依次执行的代码行，会转变为一个指令序列被执行，这个指令序列就是执行流，注意：这个指令序列跟代码顺序不一样，代码中的条件分支和跳转语句等会影响执行流。

## 逻辑线程和硬件线程

执行流描述了计算逻辑，即这个线程要做什么事情，要完成什么工作，但它没有描述物质，即这个任务由谁去做，由什么硬件去做。所以，我们说，线程是一个逻辑上的概念，也叫任务、软线程、逻辑线程，用以跟芯片的硬件线程概念做区分，芯片上线程的概念，通常指为执行指令序列而配套的实实在在的执行硬件单元，所以也叫硬线程。

线程的执行逻辑由代码描述，比如编写对一个整型数组的元素求和的函数，我们可以让一个线程承担这项工作。但一个软件线程由哪个cpu去执行、以及何时执行，则不归应用程序员管，它由操作系统决定，操作系统中的调度系统负责这项工作。

如果整型数组特别大，我们可以把这个整型数组分成多个小数组，或者理解成数组的数组（二维数组），每个线程完成一个小数组的求和，多个线程并发执行，最后再累加结果，所以，可以为了提升处理速度，而让多个线程执行相同的计算逻辑；当然，两个线程，也可以执行完全不同的计算逻辑。

如果我们把线程的计算逻辑封装成一个函数，那么函数描述了处理过程，同样的处理逻辑可以有多个执行实例，即多个线程。

## 函数、线程和核的关系

打个比方，假设有遛狗、扫地、做饭3项工作要做。

- 遛狗就是为狗系上绳子然后牵着它在小区里溜达一圈，这句话就描述了遛狗的逻辑，即对应到函数定义。
- 每项工作，最终需要人去做，人就对应到CPU/Core硬件，是工作被完成的物质基础。
- 那什么是线程？做某项工作，比如张三在遛狗，那就表示一个线程在执行，李四在扫地，是另一个线程在执行。

那上面描述的情况，会对应几个线程实例呢？是不是3项工作就对应3个线程呢？

并不是。

比如有2个房间，让2个人去打扫，1个人打扫一个房间，那么就是2个线程；也可以1个人负责，一个房间接着一个房间的打扫，那么这样就是1个线程。

也可以1个人负责所有事情，先遛狗、再扫地，然后做饭。所以多线程并不一定需要多CPU多Core，即单CPU单Core系统依然可以运行多线程，虽然最大化利用多CPU多Core的能力是多线程的一个重要目标。

可以1个人把3项工作都做了，显然1个人无法同时做多件事情，单CPU单Core也不行，操作系统通过时间分片技术应对远多于CPU数的多任务。

## 并发和并行
CPU先执行一段时间线程A，然后再执行一段时间线程B，然后再执行一段时间线程A，这就是CPU时间分片，时间分片是对调度策略的一个极度简化，实际上操作系统的调度策略非常精细。

如果一秒钟被分成大量的非常短的时间片，比如1000个1毫秒的时间片，一毫秒对人的感官而言太短了，以致于用户觉察不到延迟，仿佛计算机被该用户的任务所独占（虽然实际上并不是），把当前正在CPU上运行的任务迁走，并挑选一个新任务到CPU上执行的过程叫调度，任务调度的过程会发生context swap，即保存当前CPU上正在运行的线程状态，并恢复将要被执行的线程的状态，这个过程需要占用一些CPU时间。

- 并发：多个任务被交错执行的情况被称为多任务（线程）并发；如果一个任务的开始时间，不晚于另一个任务的结束时间，那么这2个任务就是并发执行的。
- 并行：如果多个任务在多个CPU或者多核上同时执行，齐头并进，则称为多任务并行，并行可以发生在单机多线程，也可以发生在分布式多机环境。

