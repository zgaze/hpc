# 多线程
线程是操作系统中被调度执行的最小单位，一个线程就是一个执行流，一个执行流就是一个被依次执行的指令序列。

每个线程都会有一个入口函数，线程执行从入口函数开始，一行代码接着一行代码执行，中间它可能会调用其他函数，那么它的控制流就转到了被调用的函数继续执行，被调用函数里也可以调用其他函数，这样便形成一个函数调用链，被调用函数执行完便返回调用该函数的地方，并一步步返回到线程的入口函数，等到入口函数执行完成，线程的执行流程便完成了。

假设某线程的入口函数是a，a函数里调用了b，b函数里调用了c，那么调用链是：a() -> b() -> c()。线程在执行过程中，每个被调用的函数会对应到一帧（Frame），当c函数被执行时，帧的深度是3。当c函数被执行完，便返回到b函数里调用c的地方，当b函数执行完，便返回a，即返回的过程是：c() -> b() -> a()。

被执行的代码行会被编译成汇编指令，所以，依次执行的代码行，会转变为一个指令序列被执行，这个指令序列就是执行流。

执行流描述了计算逻辑，即这个线程要做什么事情，要完成什么工作，但它没有描述物质，即这个事情由谁去做，由什么硬件去做。所以，我们说，线程是一个逻辑上的概念，也叫任务、软线程，用以跟芯片的线程概念做区分，芯片上线程的概念，通常指为执行指令序列而配套的硬件物质，所以也叫硬线程。

线程的执行逻辑由代码描述，比如写一个函数对一个整型数组的元素求和，我们可以让一个线程承担这项工作。但一个软件线程由哪个cpu去执行、以及何时执行，则是由操作系统决定，操作系统中的调度系统负责这项工作。

如果整型数组特别大，我们可以把这个整型数组分成多个小数组，或者理解成数组的数组（二维数组），每个线程完成一个小数组的求和，多个线程并发执行，最后再累加结果，所以，多个线程，可以执行相同的计算逻辑，从而提升处理速度。两个线程，也可以执行不同的逻辑。

如果我们把线程的计算逻辑封装成一个函数，那么函数描述了处理过程，同样的处理逻辑可以有多个执行实例，即多个线程。

打个比方，假设有遛狗、扫地、做饭3项工作要做。遛狗就是为狗系上绳子然后牵着它在小区里溜达一圈，这句话就描述了遛狗的逻辑，即对应到函数定义。这些工作，最终还是需要人去做，人就对应到CPU/Core(硬件)。那什么是线程？做某项工作，比如你在遛狗，那就表示一个线程。

那上面的描述，对应几个线程呢？是不是3项工作就对应3个线程呢？不是！比如你家是2室1厅，那么一家3口，可以一个人打扫一个房间，那么就是3个线程，也可以1个人一个房间接着一个房间的打扫，那么这样就是1个线程。

你可以一个人，先遛狗、再扫地，然后做饭，所以多线程并不一定需要多CPU多核，虽然多线程编程可能确实能最大化利用多cpu多核的优势，如果你一个人把3项工作都做了，显然你是无法同时做多件事情，CPU也不行，操作系统通过时间分片技术应对远多于cpu数的任务。所以，即使是单CPU单核系统，依然可以多线程执行，CPU先执行一段时间线程A，然后再执行一段时间线程B，然后再执行一段时间线程A，这种多个任务被交错执行的情况，被称为多任务（线程）并发，如果一个任务的开始时间，不晚于另一个任务的结束时间，那么这2个任务就是并发的，如果多个任务在多个CPU上同时执行，齐头并进，则称为多任务并行。

