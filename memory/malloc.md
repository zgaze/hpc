## 动态内存分配

### 动态内存分配器的历史
如果你在上世纪80年代，为unix系统编写上层应用程序，你可能无法使用动态内存分配器，因为它还不存在。你可能难以想象在脱离动态内存分配器的环境中编写程序，但实际上，它是可能的。

你要动态分配一块内存，通常是因为要到程序实际运行时才知道要申请多大的空间，比如你编写一个拼接两个字符串的函数，拼接后的结果串长度依赖于调用函数时候传递的2个参数字符串，怎么办？你可以用全局变量的方式预先申请一块全局的内存空间（就像用汇编编写程序那样），为了保险起见，你只能把这个全局存储空间预留得大一点，这种硬编码通常不是一个好主意，预留大了浪费存储空间，预留小了又不够用，但至少这样做是可行的，多个函数甚至可以复用这块空间，只要访问时间上能错开。

你也可以通过mmap系统调用申请一块内存空间，用完后用munmap解除映射。虽然mmap/munmap不如malloc/free编程接口那么快捷和高效，但它也是能正常工作的。

那为什么我们还需要动态内存分配器呢？因为虽然可以通过mmap/kmalloc这样的系统调用动态分配内存，但系统调用要陷入内核，每次动态分配内存都要陷入内核，这样的话，效率太低了，用户态的事情尽量用户态解决。

一个直观的想法：既然底层系统调用的代价高，那可不可以先申请一块存储空间，然后在用户态管理这些空间，来满足用户态对动态内存的请求，动态内存分配器通过调用mmap/sbrk等low-level调用向操作系统申请内存。这种批发转零售的思想就是动态内存分配器的设计动机，通过引入中间层，用高效的用户态调用，对抗高昂的内核态调用开销。

dlmalloc是一个著名且流行的动态内存分配器，由Doug Lea于1987年开始编写，dlmalloc就由Doug Lea名字首字母缩写而来，Doug Lea不仅开发了dlmalloc，同时也是并发编程领域的大神，是Java util.concurrent包的作者。

dlmalloc的实现只有一个源文件，虽然代码量只有5000行（且注释占了大量篇幅），但它却是一个高品质的佳作。

Doug Lea在代码里使用了大量的技巧，虽然时至今日，dlmalloc的一些技术已经显得有些落伍，但许多更先进更高效的内存分配器都从dlmalloc精巧的设计中获得了启发和灵感。

glibc默认的动态内存分配器ptmalloc就是基于dlmalloc开发的，ptmalloc通过引入arena的概念，把堆内存分割为多个不同的空间，从而减少了多线程竞争，解决了dlmalloc并发下工作的低效问题。

前面讲到，动态内存分配器引入了一个新的分层，这一层介于操作系统和应用程序之间，它的角色很神奇，因为在kernel看来，动态内存分配器依然是用户层代码，它运行在用户态，而在动态内存分配器的用户看来，它却像系统底层，它不是一般意义上的用户层代码。

当调用malloc的时候，动态内存分配器不一定会向操作系统申请内存，当调用free的时候，内存也不一定真正返还系统，这是因为动态内存分配器托管了这部分已分配的内存，用户层对动态内存的malloc请求可能从缓存得到满足，用户层主动free的内存块也有可能被动态内存分配器缓存起来，何时真正返还给系统，取决于动态内存分配器的实现策略，所以，用户层的malloc/free可能导致从os层面看到的进程的虚拟内存占用情况不变。

动态内存分配器如今早已成为标准C库的一部分，我们可以在任何支持C的开发环境下放心使用它。但有了动态内存分配器这一层，我们依然可以直接调用mmap动态申请内存，它铺在kernel之上，为应用程序开发提供服务，却没有完全屏蔽掉kernel的内存分配相关接口。

内存分配器有两种风格，一种是C/C++这种需要手动显式释放内存块，这种叫显式分配器；另一种是JAVA这种由分配器追踪被分配的内存块，在确定其不再被使用后主动将其回收，这种也叫隐式分配器，隐式分配器也叫垃圾收集器，自动释放不再被使用的内存块的过程叫垃圾收集。

隐式分配器的实现思路主要是通过引用计数技术追踪内存块被使用情况，增加一个引用就增加计数，减少一个引用就减少计数，再计数降到零的时候，便意味着该内存块不再被使用，可以释放了。

C++智能指针的实现技术跟隐式分配器的思路差不多，只不过C++智能指针是库级别的支持，这表示C++的智能指针是可选项，你可以用，也可以不用，而JAVA等是语言级别的支持，它从根本上统一管理。根据引用计数的放置的不同，又分为侵入式的引用计数（intrusive_ptr）和外置式的引用计数（shared_ptr）。

隐式分配器看起来更省事，也更安全，那为什么还需要显式的内存分配器呢？天下没有免费的午餐，你需要为GC付出额外的代价，而显式内存分配器，应用程序可以选择释放的时机，可以更精细化管理内存。

### C动态内存分配器接口
- malloc(size_t size)：分配内存块
    - 接受一个size参数，返回可用内存空间不小于size内存块的指针。glibc的ptmalloc，可以通过size_t malloc_usable_size(void* p)查询到实际可用尺寸（可能大于size），但建议你不要占这个小便宜，注意这个接口不是标准接口，它是产品相关的，你换了一个内存配置器就不一定能用
    - 返回的内存地址会做内存对齐，32位系统8字节对齐（低3位为0），64位系统16字节对齐（低4位为0）
    - size传0是合法的
- free(void* p)：释放内存块
    - free接受的参数，必须是malloc/calloc/realloc等接口返回的指针
    - free(nullptr)是合法的

### 动态内存分配器的目标
动态内存分配器要满足通用目的，即对申请的内存块的size，不应有假设，用户可能一次申请小到几个字节的内存块，也有可能一次申请上G的内存块。

另外，分配/释放的行为也各不相同，比如在申请/释放操作频繁交替进行，也有可能会先集中申请，再集中释放，只要满足释放时传入的块是之前分配返回的即可。

动态内存分配器对应用程序不应有假设，要能胜任各种场景，而上层的变化和差异极大，要在所有场景，各种情况下，有较好的综合表现，因而挑战很大，这也给场景定制的内存分配器、内存池技术发挥的舞台。

- 我们先看一看动态内存分配器的主要目标
    - 高吞吐：动态内存分配器要有高的吞吐，吞吐被定义为时间单位内满足分配/释放的次数。
    - 低延迟：从提出内存分配申请，到返回结果的时间间隔，越短越好，要立即响应分配请求
	- 高内存利用率：进程的虚拟内存空间受限于磁盘交换空间的限制，虚拟存储是有限的，需要高效利用起来，有效载荷要高，碎片要少，overhead小

### 内存碎片：内碎片 / 外碎片
内存碎片是指虽然未使用内存尺寸大于请求的内存尺寸，但因为没有完整的单块内存能满足分配请求的情况，碎片是造成堆内存利用率低的元凶，内存碎片分为内碎片和外碎片。

内碎片指分配块的实际内存大于有效载荷造成的，比如通过malloc(1)分配1字节的内存块，实际占用的内存会远大于1字节，这是因为虽然你只申请1字节，实际上动态内存分配器分配的可用内存会比1字节大，你可以通过malloc_usable_size(void* p)验证这一点；此外，内存对齐也会造成内存浪费；而且，内存分配器在会每个内存块增加头部、脚部，这也会需要额外的内存。

外碎片是指内存块与块之间的间隙，比如内存块A与B之间有5字节的间隙，内存B与C之间有3个字节间隙，这时候，需要分配8字节内存，虽然AB和BC之间的间隙加起来满足8字节的要求，但因为他们不连续，所以也没有办法利用起来。

### 动态内存管理器要处理哪些问题？
从动态内存分配器的接口malloc/free可知，动态内存分配器主要是一次从堆内存分一大块内存，然后再从这块大的内存块，分割出小块分配出去，最简单的做法就是在为这个大块内存记录一下位置（游标），这个位置初始化为大块内存的起始地址，然后下次分配的时候，先判断这个大块内存是否足够，如果不够，则再分一块大的，如果够，则将游标往后移动需要的字节数，返回游标移动前的值，下次分配则从新的游标位置开始，这样是最快的，其实很多内存池也是这么做的，当然，实际上，我们不能简单移动申请字节数大小，需要做对齐，但这影响我们的讨论。

但这有一个问题，那就是我们分配出去的块，怎么释放，释放后的块应该被复用，而且临近的块被释放，应该合并成更大的块，所以，我们要把free掉的块管理起来，比如用free list管理起来，可能还需要按size组织成不同的free list，实际上ptmalloc正是这么做的。

如果不同size有不同的free list，那释放内存块的时候，因为释放接口（free）只接受一个void*参数，那怎么获得这个内存块的size呢？实际上藏在块的头部，malloc返回的时候，并非直接返回块的其实地址，在起始的几个字节，会被用来作为头部，头部里面保存有块的size，还有其他一些信息，用来辅助做前述的空闲块合并。

实际上，内存块，不光有头部，还有脚部，头尾部用来记载一些有用的信息，这就不难理解为什么malloc一个字节，实际上消耗的内存远大于1字节。

动态内存分配器，会维护多个不同size的free list，但不能为所有size维护单独的free list，因为size的范围实在太大了，于是，只会选择2^n这种固定size，这样，当你申请20字节的时候，它会帮你向上取到32字节，然后去32字节的fixed-size freelist去找内存块，如果找不到，那就去64字节的freelist借用一个过来，再劈成2半，剩下的32字节块加入fixed-size为32的free list，如果还是找不到，就通过sbrk去调堆顶指针，获得一块更大的虚拟内存，实际实现远比这个复杂精巧，比如对huge size会直接mmap一块，比如还需要考虑到多线程的分配效率问题，但主要的思路差不多是这样了。

- 一次malloc要耗费多少cpu时间
- 几种经典的内存分配器：ptmalloc / tcmalloc / jemalloc
- 动态内存分配器的挑战（引出为什么需要MemPool）

